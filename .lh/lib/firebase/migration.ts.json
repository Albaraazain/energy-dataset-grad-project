{
    "sourceFile": "lib/firebase/migration.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1730136871759,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1730138779867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,33 +1,110 @@\n import { firestoreDb, categoryConverter, linkConverter } from './firestore';\r\n import { Category, Link } from '@/types';\r\n-import { setDoc } from 'firebase/firestore';\r\n+import { setDoc, writeBatch, doc } from 'firebase/firestore';\r\n \r\n export async function migrateDataToFirestore(categories: Category[]) {\r\n   try {\r\n+    // Process categories in batches to avoid hitting Firestore limits\r\n+    const batchSize = 500;\r\n+    let operationsCount = 0;\r\n+    let currentBatch = writeBatch(firestoreDb.categories.getRef().firestore);\r\n+\r\n     for (const category of categories) {\r\n-      // Create category document\r\n+      // Create category document reference\r\n       const categoryRef = firestoreDb.categories.getDocRef(category.id.toString());\r\n       \r\n       // Prepare category data (excluding links array)\r\n       const { links, ...categoryData } = category;\r\n       \r\n-      // Add category\r\n-      await setDoc(categoryRef, categoryConverter.toFirestore(categoryData));\r\n-      \r\n-      // Add links as subcollection\r\n+      // Add category to batch\r\n+      currentBatch.set(categoryRef, categoryConverter.toFirestore(categoryData));\r\n+      operationsCount++;\r\n+\r\n+      // Process links for this category\r\n       for (const link of links) {\r\n+        // Create a document reference for the link using a consistent ID\r\n         const linkRef = firestoreDb.categories.links.getDocRef(\r\n           category.id.toString(),\r\n-          link.title // Using title as ID since it should be unique within a category\r\n+          // Use a slug-like ID derived from the title\r\n+          link.title.toLowerCase().replace(/[^a-z0-9]+/g, '-')\r\n         );\r\n         \r\n-        await setDoc(linkRef, linkConverter.toFirestore(link));\r\n+        // Add link to batch\r\n+        currentBatch.set(linkRef, linkConverter.toFirestore({\r\n+          ...link,\r\n+          // Add default notes structure if not present\r\n+          notes: link.notes || {\r\n+            content: '',\r\n+            lastUpdated: new Date().toISOString()\r\n+          }\r\n+        }));\r\n+        operationsCount++;\r\n+\r\n+        // If we've hit the batch limit, commit and start a new batch\r\n+        if (operationsCount >= batchSize) {\r\n+          await currentBatch.commit();\r\n+          currentBatch = writeBatch(firestoreDb.categories.getRef().firestore);\r\n+          operationsCount = 0;\r\n+        }\r\n       }\r\n     }\r\n-    \r\n+\r\n+    // Commit any remaining operations\r\n+    if (operationsCount > 0) {\r\n+      await currentBatch.commit();\r\n+    }\r\n+\r\n+    console.log('Migration completed successfully');\r\n     return true;\r\n   } catch (error) {\r\n     console.error('Migration error:', error);\r\n     return false;\r\n   }\r\n+}\r\n+\r\n+// Helper function to validate data before migration\r\n+export function validateMigrationData(categories: Category[]): boolean {\r\n+  if (!Array.isArray(categories)) {\r\n+    console.error('Invalid categories data: not an array');\r\n+    return false;\r\n+  }\r\n+\r\n+  for (const category of categories) {\r\n+    if (!category.id || !category.title || !category.icon || !category.description) {\r\n+      console.error('Invalid category data:', category);\r\n+      return false;\r\n+    }\r\n+\r\n+    if (!Array.isArray(category.links)) {\r\n+      console.error('Invalid links data for category:', category.title);\r\n+      return false;\r\n+    }\r\n+\r\n+    for (const link of category.links) {\r\n+      if (!link.title || !link.url || !link.type) {\r\n+        console.error('Invalid link data in category:', category.title, link);\r\n+        return false;\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  return true;\r\n+}\r\n+\r\n+// Function to clean up any incomplete or failed migrations\r\n+export async function cleanupFailedMigration(categories: Category[]) {\r\n+  try {\r\n+    const batch = writeBatch(firestoreDb.categories.getRef().firestore);\r\n+    \r\n+    for (const category of categories) {\r\n+      const categoryRef = firestoreDb.categories.getDocRef(category.id.toString());\r\n+      batch.delete(categoryRef);\r\n+    }\r\n+    \r\n+    await batch.commit();\r\n+    return true;\r\n+  } catch (error) {\r\n+    console.error('Cleanup error:', error);\r\n+    return false;\r\n+  }\r\n }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1730136871759,
            "name": "Commit-0",
            "content": "import { firestoreDb, categoryConverter, linkConverter } from './firestore';\r\nimport { Category, Link } from '@/types';\r\nimport { setDoc } from 'firebase/firestore';\r\n\r\nexport async function migrateDataToFirestore(categories: Category[]) {\r\n  try {\r\n    for (const category of categories) {\r\n      // Create category document\r\n      const categoryRef = firestoreDb.categories.getDocRef(category.id.toString());\r\n      \r\n      // Prepare category data (excluding links array)\r\n      const { links, ...categoryData } = category;\r\n      \r\n      // Add category\r\n      await setDoc(categoryRef, categoryConverter.toFirestore(categoryData));\r\n      \r\n      // Add links as subcollection\r\n      for (const link of links) {\r\n        const linkRef = firestoreDb.categories.links.getDocRef(\r\n          category.id.toString(),\r\n          link.title // Using title as ID since it should be unique within a category\r\n        );\r\n        \r\n        await setDoc(linkRef, linkConverter.toFirestore(link));\r\n      }\r\n    }\r\n    \r\n    return true;\r\n  } catch (error) {\r\n    console.error('Migration error:', error);\r\n    return false;\r\n  }\r\n}"
        }
    ]
}